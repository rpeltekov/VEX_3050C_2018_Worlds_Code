#pragma config(Sensor, in2,    liftLeftPot,    sensorPotentiometer)
#pragma config(Sensor, in3,    liftRightPot,   sensorPotentiometer)
#pragma config(Sensor, in4,    armPot,         sensorPotentiometer)
#pragma config(Sensor, in5,    driveGyro,      sensorGyro)
#pragma config(Sensor, in7,    mobilePot,      sensorPotentiometer)
#pragma config(Sensor, dgtl7,  MOSI,           sensorDigitalOut)
#pragma config(Sensor, dgtl8,  SCLK,           sensorDigitalOut)
#pragma config(Sensor, dgtl11, DriveEnc,       sensorQuadEncoder)
#pragma config(Motor,  port1,           mobileGoal,    tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           driveBL,       tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           driveFR,       tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           liftL,         tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           intBarL,       tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           intBarR,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           liftR,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           driveBR,       tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           driveFL,       tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port10,          roller,        tmotorVex393HighSpeed_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// Declare VEX as the robot platform

#pragma platform(VEX)

// Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

// **** Important programmer notes ****
//
// When upgrading ROBOTC the Robot Platform Settings are lost and must be reset
// otherwise compiler error will result. Ensure the following are set:
// 		Robot -> Platform Type -> VEX 2.0 Cortex
// 		Robot -> Platform Type -> VEX Robotics -> VEX 2.0 Cortex
// 		Robot -> Platform Type -> Natural Language (PLTW)
//
//
// Note: Sometime when upgrading FW on the controller and/or joystick, the FW for the
//       VEXNet Keys must also be upgraded. The symptom of needing this upgrade is a
//       failure of the controller and joystick to communicate with each other.
//
//
// Note: When RobotC refuses to download code to the robot, first try manually selecting the
//       COM port. If that doesn't work then it may be necessary reload the firmware. First
//       update the main FW and then the RobotC FW. Don't forget to rename robot afterwards.
//
//
// Variable info:
//
//		int, short, word - 2 bytes
//		long - 4 bytes
//		SensorValue() returns 2 byte value

// Control debugger windows by defining these pragmas
#pragma DebuggerWindows("debugStream")

#include "3050CLib.c"		// Utility routines to simplify programming
#include "3050CMultiTask.c"  // Motor slew control
//--------------------------------
// Delcarations

// Initialize
void initialize();
void initializeGyro();
void selectTeamAlliance();

// Controller Input
//void processController();

// Autonomous
//void autonomousRoutines();


// Robot Action

//Functions

task autonConeHold();
task moveLiftDownTask();
task holdArmIn();
task moveLiftUpTask();
void moveArmOut();
void moveArmIn();
void moveArm(bool forward);
void dontMoveArm();
void moveLiftUp(int speed, int distance);
void moveLiftDown(int speed, int distance);
void moveLiftAuto(int speed, int distance);
void rollerIntake(int speed);
void rollerOutake(int speed, int time);

void autoDrivePIDControl (int distance, bool drive);
void autoGyroPIDControl (int setAngle, bool turn);

void drive(int left, int right);
void clearDriveEnc();
void moveMobileGoalOutAuto();
void moveMobileGoalInAuto();
void moveMobileGoalOut();
void moveMobileGoalIn();
void drivePushIn();
void drivePushIn(int speed);
void drivePushIn(int timeToMove, int speed);


int liftDownDistance = 1800;
int liftUpDistance = 2200;
bool hold;

// Constants and global vars
const byte MIN_JOYSTICK_THRESHOLD = 15;

const byte AUTONOMOUS_MODE_LEFT_MOBILE_GOAL_20 = 1;
const byte AUTONOMOUS_MODE_LEFT_2MOBILE_GOAL_20 = 2;
const byte AUTONOMOUS_MODE_RIGHT_MOBILE_GOAL_20 = 3;
const byte AUTONOMOUS_MODE_RIGHT_2MOBILE_GOAL_20 = 4;
const byte AUTONOMOUS_MODE_RIGHT_3MOBILE_GOAL_5 = 5;
const byte AUTONOMOUS_MODE_RIGHT_3MOBILE_GOAL_10 = 6;
const byte AUTONOMOUS_MODE_LEFT_3MOBILE_GOAL_5 = 7;
const byte AUTONOMOUS_MODE_LEFT_3MOBILE_GOAL_10 = 8;
const byte Interference = 9
const byte Stationary = 10;
const byte Default = 11;
byte autonomousMode = Default;


unsigned long autonomousStartTime;

const byte AUTONOMOUS = 1;
const byte USER_CONTROL = 2;
byte robotMode = 1;

const int ROLLER_DEFAULT_RATE = 15;

bool stacking = false;
bool stackPrev = false;
bool justStacked = false;

bool increaseStackLvl;

bool armIsReallyBack;

bool liftLeftAtPosition;
bool liftRightAtPosition;
bool driveAtPosition;
bool turnAtPosition;


bool outakeFinished = false;


bool mobileGoalIsOut;

int armPower;

int drivePositionError = 40;
int turnPositionError = 20;
int driveTurnPositionError = 200;

const float PID_ENCODER_SCALE =	830/24; //to scale inches into ticks. there are 34.708333 ticks per inch
const float PID_GYRO_SCALE = (1890/180);		//to scale degrees into ticks. there are 10 ticks per degree for gyro

//Drive PID values
float drivekp = .15;//0.63;
float driveki = 0.0000;//0.0000009;
float drivekd = 13;//75;
int bias = -8;

//Turn PID values
float turnkp = 0.23;
float turnki = 0.000000;
float turnkd = 40;

//Turn Drive PID values
float turnDrivekp;
float turnDriveki;
float turnDrivekd;

//Drive Turn PID values
float driveTurnkp;
float driveTurnki;
float driveTurnkd;

float turnError;

int driveCurrent;
int gyroCurrent;

int rollerSpeed;

void pre_auton()
{
	bStopTasksBetweenModes = true;

	clearDebugStream();
	writeDebugStreamLine("Pre-Autonomous...");

	initializeGyro();
	if (bIfiRobotDisabled){
		initialize();
		selectTeamAlliance();
	}
	else {
		initialize();

	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////AUTONOMOUS PROGRAM SECTION////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

task autonomousRoutines()
{
	switch (autonomousMode) {
	case AUTONOMOUS_MODE_LEFT_MOBILE_GOAL_20:
		//placeholder. Look in 3050CAuton for
		writeDebugStreamLine("In Auton mogo 20 point blue left");

		clearDriveEnc();

		hold = true;
		startTask(autonConeHold);

		driveAtPosition = false;
		clearTimer(T1);
		clearTimer(T2);
		while (!driveAtPosition) {
			if(time1[T1] > 400)
				moveMobileGoalOut();
			if(time1[T2] > 50 && time1[T2] < 400)
				moveLiftUp(-127, 2100);

			autoDrivePIDControl(50.5, true);
		}
		drivePushIn();
		moveMobileGoalInAuto();

		startTask(moveLiftDownTask);

		driveAtPosition = false;
		clearTimer(T1);
		clearDriveEnc();
		while(!driveAtPosition){
			autoDrivePIDControl(-48, true);
			if (time1[T1] > 300 && time1[T1] < 600)
				hold = false;
			else
				hold = true;
		}

		clearTimer(T1);
		turnAtPosition = false;
		while(!turnAtPosition){
			autoGyroPIDControl(-45, true);
		}

		clearTimer(T1);
		clearDriveEnc();
		driveAtPosition = false;
		while(!driveAtPosition){
			autoDrivePIDControl(-27, true);
		}

		clearTimer(T1);
		turnAtPosition = false;
		while(!turnAtPosition){
			autoGyroPIDControl(-140, true);
		}

		clearTimer(T1);
		while(time1[T1] < 700)
			moveLiftUp(-127, 2300);

		wait1Msec(300);
		clearTimer(T1);
		clearDriveEnc();
		driveAtPosition = false;
		while(!driveAtPosition){
			autoDrivePIDControl(29 , true);
			moveMobileGoalOut();
		}

		clearTimer(T1);
		while(time1[T1] < 500){
			moveMobileGoalIn();
		}

		clearTimer(T1);
		clearDriveEnc();
		driveAtPosition = false;
		while(!driveAtPosition){
			autoDrivePIDControl(-24, true);
			moveMobileGoalIn();
		}
		break;

		////////////////////////////////////////////////////////////////////////////////
		case AUTONOMOUS_MODE_LEFT_2MOBILE_GOAL_20:
		writeDebugStreamLine("In Auton mogo 20 point blue 2 cone left");

		clearDriveEnc();

		hold = true;
		startTask(autonConeHold);

		driveAtPosition = false;
		clearTimer(T1);
		while (!driveAtPosition) {
			if(time1[T1] > 400)
				moveMobileGoalOut();
			if(time1[T1] > 50 && time1[T1] < 400)
				moveLiftUp(-127, 2100);

			autoDrivePIDControl(50.5, true);
		}
		drivePushIn();
		moveMobileGoalInAuto();

		startTask(moveLiftDownTask);

		driveAtPosition = false;
		clearTimer(T1);
		clearDriveEnc();
		hold = false;
		wait1Msec(300);
		stopTask(moveLiftDownTask);
		startTask(moveLiftUpTask);
		drivePushIn(200, 50);

		stopTask(moveLiftUpTask);
		liftDownDistance = 1700;
		startTask(moveLiftDownTask);
		armIsReallyBack = true;
		clearTimer(T1);
		hold = true;
		startTask(autonConeHold);
		while(armIsReallyBack && (time1[T1] < 300)){
			moveArm(true);
		}
		dontMoveArm();

		stopTask(moveLiftDownTask);
		wait1Msec(500);
		moveLiftAuto(-127, 2300);

		clearTimer(T1);
		armIsReallyBack = false;
		while(!armIsReallyBack && (time1[T1] < 300)){
			moveArm(false);
		}
		dontMoveArm();

		liftDownDistance = 2100;
		startTask(moveLiftDownTask);
		driveAtPosition = false;
		clearTimer(T1);
		clearDriveEnc();
		while(!driveAtPosition){
			autoDrivePIDControl(-56, true);
			if (time1[T1] > 350)
				hold = false;
		}

		clearTimer(T1);
		turnAtPosition = false;
		while(!turnAtPosition){
			autoGyroPIDControl(-45, true);
		}

		clearTimer(T1);
		clearDriveEnc();
		driveAtPosition = false;
		while(!driveAtPosition){
			autoDrivePIDControl(-27, true);
		}

		clearTimer(T1);
		turnAtPosition = false;
		while(!turnAtPosition){
			autoGyroPIDControl(-140, true);
		}

		hold = false;
		startTask(autonConeHold);
		clearTimer(T1);
		while(time1[T1] < 700)
			moveLiftUp(-127, 2200);

		wait1Msec(300);
		clearTimer(T1);
		clearDriveEnc();
		startTask(holdArmIn);
		driveAtPosition = false;
		while(!driveAtPosition){
			autoDrivePIDControl(28, true);
			if(time1[T1] > 100 && time1[T1] < 700)
				moveMobileGoalOut();
		}


		clearTimer(T1);
		clearDriveEnc();
		driveAtPosition = false;
		while(!driveAtPosition && time1[T1] < 600){
			if (time1[T1] < 500)
				moveMobileGoalIn();
			if (time1[T1] > 300)
				drivePushIn(-127);
		}
		drivePushIn(0);
		break;

		///////////////////////////////////////////////////////////////////////////////////////////////////////

		case AUTONOMOUS_MODE_RIGHT_MOBILE_GOAL_20:
		writeDebugStreamLine("In Auton mogo 20 point blue left");

		clearDriveEnc();

		hold = true;
		startTask(autonConeHold);

		driveAtPosition = false;
		clearTimer(T1);
		clearTimer(T2);
		while (!driveAtPosition) {
			if(time1[T1] > 400)
				moveMobileGoalOut();
			if(time1[T2] > 50 && time1[T2] < 400)
				moveLiftUp(-127, 2100);

			autoDrivePIDControl(50.5, true);
		}
		drivePushIn();
		moveMobileGoalInAuto();

		startTask(moveLiftDownTask);

		driveAtPosition = false;
		clearTimer(T1);
		clearDriveEnc();
		while(!driveAtPosition){
			autoDrivePIDControl(-48, true);
			if (time1[T1] > 300 && time1[T1] < 600)
				hold = false;
			else
				hold = true;
		}

		clearTimer(T1);
		turnAtPosition = false;
		while(!turnAtPosition){
			autoGyroPIDControl(45, true);
		}

		clearTimer(T1);
		clearDriveEnc();
		driveAtPosition = false;
		while(!driveAtPosition){
			autoDrivePIDControl(-27, true);
		}

		clearTimer(T1);
		turnAtPosition = false;
		while(!turnAtPosition){
			autoGyroPIDControl(140, true);
		}

		hold = false;
		startTask(autonConeHold);
		clearTimer(T1);
		while(time1[T1] < 700)
			moveLiftUp(-127, 2200);

		wait1Msec(300);
		clearTimer(T1);
		clearDriveEnc();
		driveAtPosition = false;
		while(!driveAtPosition){
			autoDrivePIDControl(28, true);
			if (time1[T1] < 200)
				moveArm(false);
			else
				dontMoveArm();
		}

		startTask(holdArmIn);
		moveMobileGoalOutAuto();

		clearTimer(T1);
		clearDriveEnc();
		driveAtPosition = false;
		while(!driveAtPosition && time1[T1] < 600){
			if (time1[T1] < 500)
				moveMobileGoalIn();
			if (time1[T1] > 300)
				drivePushIn(-127);
		}
		drivePushIn(0);
		break;

		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		case AUTONOMOUS_MODE_RIGHT_2MOBILE_GOAL_20:
		writeDebugStreamLine("In Auton mogo 20 point blue 2 cone left");

		clearDriveEnc();

		hold = true;
		startTask(autonConeHold);

		driveAtPosition = false;
		clearTimer(T1);
		while (!driveAtPosition) {
			if(time1[T1] > 400)
				moveMobileGoalOut();
			if(time1[T1] > 50 && time1[T1] < 400)
				moveLiftUp(-127, 2100);

			autoDrivePIDControl(50.5, true);
		}
		drivePushIn();
		moveMobileGoalInAuto();

		startTask(moveLiftDownTask);

		driveAtPosition = false;
		clearTimer(T1);
		clearDriveEnc();
		hold = false;
		wait1Msec(300);
		stopTask(moveLiftDownTask);
		startTask(moveLiftUpTask);
		drivePushIn(200, 50);

		stopTask(moveLiftUpTask);
		liftDownDistance = 1700;
		startTask(moveLiftDownTask);
		armIsReallyBack = true;
		clearTimer(T1);
		hold = true;
		startTask(autonConeHold);
		while(armIsReallyBack && (time1[T1] < 300)){
			moveArm(true);
		}
		dontMoveArm();

		stopTask(moveLiftDownTask);
		wait1Msec(500);
		moveLiftAuto(-127, 2300);

		clearTimer(T1);
		armIsReallyBack = false;
		while(!armIsReallyBack && (time1[T1] < 300)){
			moveArm(false);
		}
		dontMoveArm();

		liftDownDistance = 2100;
		startTask(moveLiftDownTask);
		driveAtPosition = false;
		clearTimer(T1);
		clearDriveEnc();
		while(!driveAtPosition){
			autoDrivePIDControl(-56, true);
			if (time1[T1] > 350)
				hold = false;
		}

		clearTimer(T1);
		turnAtPosition = false;
		while(!turnAtPosition){
			autoGyroPIDControl(45, true);
		}

		clearTimer(T1);
		clearDriveEnc();
		driveAtPosition = false;
		while(!driveAtPosition){
			autoDrivePIDControl(-25, true);
		}

		clearTimer(T1);
		turnAtPosition = false;
		while(!turnAtPosition){
			autoGyroPIDControl(140, true);
		}

		hold = false;
		startTask(autonConeHold);
		clearTimer(T1);
		while(time1[T1] < 700)
			moveLiftUp(-127, 2200);

		wait1Msec(300);
		clearTimer(T1);
		clearDriveEnc();
		startTask(holdArmIn);
		driveAtPosition = false;
		while(!driveAtPosition){
			autoDrivePIDControl(28, true);
			if(time1[T1] > 100 && time1[T1] < 700)
				moveMobileGoalOut();
		}


		clearTimer(T1);
		clearDriveEnc();
		driveAtPosition = false;
		while(!driveAtPosition && time1[T1] < 600){
			if (time1[T1] < 500)
				moveMobileGoalIn();
			if (time1[T1] > 300)
				drivePushIn(-127);
		}
		drivePushIn(0);
				//		liftDownDistance = 2100;
				//startTask(moveLiftDownTask);
				//driveAtPosition = false;
				//clearTimer(T1);
				//clearDriveEnc();
				//while(!driveAtPosition){
				//	autoDrivePIDControl(-56, true);
				//	if (time1[T1] > 350)
				//		hold = false;
				//}

				//clearTimer(T1);
				//turnAtPosition = false;
				//while(!turnAtPosition){
				//	autoGyroPIDControl(40, true);
				//}

				//clearTimer(T1);
				//clearDriveEnc();
				//driveAtPosition = false;
				//while(!driveAtPosition){
				//	autoDrivePIDControl(-25, true);
				//}

				//clearTimer(T1);
				//turnAtPosition = false;
				//while(!turnAtPosition){
				//	autoGyroPIDControl(140, true);
				//}

				//hold = false;
				//startTask(autonConeHold);
				//clearTimer(T1);
				//while(time1[T1] < 700)
				//	moveLiftUp(-127, 2200);

				//wait1Msec(300);
				//clearTimer(T1);
				//clearDriveEnc();
				//startTask(holdArmIn);
				//driveAtPosition = false;
				//while(!driveAtPosition){
				//	autoDrivePIDControl(28, true);
				//	if(time1[T1] > 200 && time1[T1] < 700)
				//		moveMobileGoalOut();
				//}

				//startTask(holdArmIn);
				//clearTimer(T1);
				//clearDriveEnc();
				//driveAtPosition = false;
				//while(!driveAtPosition && time1[T1] < 600){
				//	if (time1[T1] < 500)
				//		moveMobileGoalIn();
				//	if (time1[T1] > 300)
				//		drivePushIn(-127);
				//}
				//drivePushIn(0);
		break;

	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		case AUTONOMOUS_MODE_RIGHT_3MOBILE_GOAL_5:
		writeDebugStreamLine("In Auton mogo 20 point blue 2 cone left");

		clearDriveEnc();

		hold = true;
		startTask(autonConeHold);

		driveAtPosition = false;
		clearTimer(T1);
		while (!driveAtPosition) {//drive forward
			if(time1[T1] > 400)
				moveMobileGoalOut();
			if(time1[T1] > 50 && time1[T1] < 400)
				moveLiftUp(-127, 2100);

			autoDrivePIDControl(50.5, true);
		}
		drivePushIn();
		moveMobileGoalInAuto();

		startTask(moveLiftDownTask);

		driveAtPosition = false;
		clearTimer(T1);
		clearDriveEnc();
		hold = false;
		wait1Msec(300);
		stopTask(moveLiftDownTask);
		startTask(moveLiftUpTask);
		drivePushIn(200, 50);//push in for cone 2

		stopTask(moveLiftUpTask);
		liftDownDistance = 1700;
		startTask(moveLiftDownTask);//move lift down to grab
		armIsReallyBack = true;
		clearTimer(T1);
		hold = true;
		while(armIsReallyBack && (time1[T1] < 300)){//movearm down
			moveArm(true);
			rollerIntake(127);
		}
		startTask(autonConeHold);
		dontMoveArm();

		stopTask(moveLiftDownTask);
		wait1Msec(500);
		moveLiftAuto(-127, 2300);//lift up

		clearTimer(T1);
		armIsReallyBack = false;
		while(!armIsReallyBack && (time1[T1] < 300)){//move arm in
			moveArm(false);
		}
		dontMoveArm();
		startTask(moveLiftDownTask);

		driveAtPosition = false;				//cone 3
		clearTimer(T1);
		clearDriveEnc();
		wait1Msec(150);
		hold = false;								//release cone2
		wait1Msec(100);
		stopTask(moveLiftDownTask); //lift up
		liftUpDistance = 2300;
		startTask(moveLiftUpTask);
		drivePushIn(300, 100);	//push in for other cone

		stopTask(moveLiftUpTask);
		liftDownDistance = 1600;
		startTask(moveLiftDownTask);//move lift down to grab
		armIsReallyBack = true;
		clearTimer(T1);
		hold = true;
		while(armIsReallyBack && (time1[T1] < 300)){//movearm in
			rollerIntake(127);
			moveArm(true);
		}
		startTask(autonConeHold);
		dontMoveArm();

		stopTask(moveLiftDownTask);
		wait1Msec(500);
		moveLiftAuto(-127, 2400);

		clearTimer(T1);
		armIsReallyBack = false;
		while(!armIsReallyBack && (time1[T1] < 300)){
			moveArm(false);
		}
		dontMoveArm();

		liftDownDistance = 2200;//start driving back
		startTask(moveLiftDownTask);
		driveAtPosition = false;
		clearTimer(T1);
		clearDriveEnc();
		while(!driveAtPosition){
			autoDrivePIDControl(-50, true);
			if (time1[T1] > 350)
				hold = false;
		}

		moveLiftAuto(-127, 2100);

		clearTimer(T1);
		turnAtPosition = false;
		while(!turnAtPosition){
			autoGyroPIDControl(-220, true);
		}

		clearTimer(T1);
		clearDriveEnc();
		drivePushIn(100, 70);

		hold = false;
		startTask(autonConeHold);
		clearTimer(T1);
		while(time1[T1] < 700)
			moveLiftUp(-127, 2200);

		startTask(holdArmIn);
		moveMobileGoalOutAuto();

		clearTimer(T1);
		clearDriveEnc();
		driveAtPosition = false;
		while(!driveAtPosition && time1[T1] < 600){
			if (time1[T1] > 500)
				moveMobileGoalIn();
			if (time1[T1] > 300)
				drivePushIn(-127);
		}
		drivePushIn(0);
		break;


	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		case AUTONOMOUS_MODE_RIGHT_3MOBILE_GOAL_10:
		writeDebugStreamLine("In Auton mogo 20 point blue 2 cone left");

		clearDriveEnc();

		hold = true;
		startTask(autonConeHold);

		driveAtPosition = false;
		clearTimer(T1);
		while (!driveAtPosition) {//drive forward
			if(time1[T1] > 400)
				moveMobileGoalOut();
			if(time1[T1] > 50 && time1[T1] < 400)
				moveLiftUp(-127, 2100);

			autoDrivePIDControl(50.5, true);
		}
		drivePushIn();
		moveMobileGoalInAuto();

		startTask(moveLiftDownTask);

		driveAtPosition = false;
		clearTimer(T1);
		clearDriveEnc();
		hold = false;
		wait1Msec(300);
		stopTask(moveLiftDownTask);
		startTask(moveLiftUpTask);
		drivePushIn(200, 50);//push in for cone 2

		stopTask(moveLiftUpTask);
		liftDownDistance = 1700;
		startTask(moveLiftDownTask);//move lift down to grab
		armIsReallyBack = true;
		clearTimer(T1);
		hold = true;
		while(armIsReallyBack && (time1[T1] < 300)){//movearm down
			moveArm(true);
			rollerIntake(127);
		}
		startTask(autonConeHold);
		dontMoveArm();

		stopTask(moveLiftDownTask);
		wait1Msec(500);
		moveLiftAuto(-127, 2300);//lift up

		clearTimer(T1);
		armIsReallyBack = false;
		while(!armIsReallyBack && (time1[T1] < 300)){//move arm in
			moveArm(false);
		}
		dontMoveArm();
		startTask(moveLiftDownTask);

		driveAtPosition = false;				//cone 3
		clearTimer(T1);
		clearDriveEnc();
		wait1Msec(150);
		hold = false;								//release cone2
		wait1Msec(100);
		stopTask(moveLiftDownTask); //lift up
		liftUpDistance = 2300;
		startTask(moveLiftUpTask);
		drivePushIn(300, 100);	//push in for other cone

		stopTask(moveLiftUpTask);
		liftDownDistance = 1600;
		startTask(moveLiftDownTask);//move lift down to grab
		armIsReallyBack = true;
		clearTimer(T1);
		hold = true;
		while(armIsReallyBack && (time1[T1] < 300)){//movearm in
			rollerIntake(127);
			moveArm(true);
		}
		startTask(autonConeHold);
		dontMoveArm();

		stopTask(moveLiftDownTask);
		wait1Msec(500);
		moveLiftAuto(-127, 2400);

		clearTimer(T1);
		armIsReallyBack = false;
		while(!armIsReallyBack && (time1[T1] < 300)){
			moveArm(false);
		}
		dontMoveArm();

		liftDownDistance = 2200;//start driving back
		startTask(moveLiftDownTask);
		driveAtPosition = false;
		clearTimer(T1);
		clearDriveEnc();
		while(!driveAtPosition){
			autoDrivePIDControl(-78, true);
			if (time1[T1] > 350)
				hold = false;
		}

		clearTimer(T1);
		turnAtPosition = false;
		while(!turnAtPosition){
			autoGyroPIDControl(-220, true);
		}

		clearTimer(T1);
		clearDriveEnc();
		driveAtPosition = false;
		drivePushIn(300, 100);

		hold = false;
		startTask(autonConeHold);
		clearTimer(T1);
		while(time1[T1] < 700)
			moveLiftUp(-127, 2200);

		startTask(holdArmIn);
		moveMobileGoalOutAuto();

		clearTimer(T1);
		clearDriveEnc();
		driveAtPosition = false;
		while(!driveAtPosition && time1[T1] < 1000){
			if (time1[T1] > 500)
				moveMobileGoalIn();
			if (time1[T1] > 300)
				drivePushIn(-127);
		}
		drivePushIn(0);
		break;
			//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		case AUTONOMOUS_MODE_LEFT_3MOBILE_GOAL_5:
		writeDebugStreamLine("In Auton mogo 20 point blue 2 cone left");

		clearDriveEnc();

		hold = true;
		startTask(autonConeHold);

		driveAtPosition = false;
		clearTimer(T1);
		while (!driveAtPosition) {//drive forward
			if(time1[T1] > 400)
				moveMobileGoalOut();
			if(time1[T1] > 50 && time1[T1] < 400)
				moveLiftUp(-127, 2100);

			autoDrivePIDControl(50.5, true);
		}
		drivePushIn();
		moveMobileGoalInAuto();

		startTask(moveLiftDownTask);

		driveAtPosition = false;
		clearTimer(T1);
		clearDriveEnc();
		hold = false;
		wait1Msec(300);
		stopTask(moveLiftDownTask);
		startTask(moveLiftUpTask);
		drivePushIn(200, 50);//push in for cone 2

		stopTask(moveLiftUpTask);
		liftDownDistance = 1700;
		startTask(moveLiftDownTask);//move lift down to grab
		armIsReallyBack = true;
		clearTimer(T1);
		hold = true;
		while(armIsReallyBack && (time1[T1] < 300)){//movearm down
			moveArm(true);
			rollerIntake(127);
		}
		startTask(autonConeHold);
		dontMoveArm();

		stopTask(moveLiftDownTask);
		wait1Msec(500);
		moveLiftAuto(-127, 2300);//lift up

		clearTimer(T1);
		armIsReallyBack = false;
		while(!armIsReallyBack && (time1[T1] < 300)){//move arm in
			moveArm(false);
		}
		dontMoveArm();
		startTask(moveLiftDownTask);

		driveAtPosition = false;				//cone 3
		clearTimer(T1);
		clearDriveEnc();
		wait1Msec(150);
		hold = false;								//release cone2
		wait1Msec(100);
		stopTask(moveLiftDownTask); //lift up
		liftUpDistance = 2300;
		startTask(moveLiftUpTask);
		drivePushIn(300, 100);	//push in for other cone

		stopTask(moveLiftUpTask);
		liftDownDistance = 1600;
		startTask(moveLiftDownTask);//move lift down to grab
		armIsReallyBack = true;
		clearTimer(T1);
		hold = true;
		while(armIsReallyBack && (time1[T1] < 300)){//movearm in
			rollerIntake(127);
			moveArm(true);
		}
		startTask(autonConeHold);
		dontMoveArm();

		stopTask(moveLiftDownTask);
		wait1Msec(500);
		moveLiftAuto(-127, 2400);

		clearTimer(T1);
		armIsReallyBack = false;
		while(!armIsReallyBack && (time1[T1] < 300)){
			moveArm(false);
		}
		dontMoveArm();

		liftDownDistance = 2200;//start driving back
		startTask(moveLiftDownTask);
		driveAtPosition = false;
		clearTimer(T1);
		clearDriveEnc();
		while(!driveAtPosition){
			autoDrivePIDControl(-60, true);
			if (time1[T1] > 350)
				hold = false;
		}

		clearTimer(T1);
		turnAtPosition = false;
		while(!turnAtPosition){
			autoGyroPIDControl(-220, true);
		}

		clearTimer(T1);
		clearDriveEnc();
		driveAtPosition = false;
		drivePushIn(100, 70);

		hold = false;
		startTask(autonConeHold);
		clearTimer(T1);
		while(time1[T1] < 700)
			moveLiftUp(-127, 2200);

		startTask(holdArmIn);
		moveMobileGoalOutAuto();

		clearTimer(T1);
		clearDriveEnc();
		driveAtPosition = false;
		while(!driveAtPosition && time1[T1] < 600){
			if (time1[T1] > 500)
				moveMobileGoalIn();
			if (time1[T1] > 300)
				drivePushIn(-127);
		}
		drivePushIn(0);
		break;

			//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		case AUTONOMOUS_MODE_LEFT_3MOBILE_GOAL_10:
		writeDebugStreamLine("In Auton mogo 20 point blue 2 cone left");

		clearDriveEnc();

		hold = true;
		startTask(autonConeHold);

		driveAtPosition = false;
		clearTimer(T1);
		while (!driveAtPosition) {//drive forward
			if(time1[T1] > 400)
				moveMobileGoalOut();
			if(time1[T1] > 50 && time1[T1] < 400)
				moveLiftUp(-127, 2100);

			autoDrivePIDControl(50.5, true);
		}
		drivePushIn();
		moveMobileGoalInAuto();

		startTask(moveLiftDownTask);

		driveAtPosition = false;
		clearTimer(T1);
		clearDriveEnc();
		hold = false;
		wait1Msec(300);
		stopTask(moveLiftDownTask);
		startTask(moveLiftUpTask);
		drivePushIn(200, 50);//push in for cone 2

		stopTask(moveLiftUpTask);
		liftDownDistance = 1700;
		startTask(moveLiftDownTask);//move lift down to grab
		armIsReallyBack = true;
		clearTimer(T1);
		hold = true;
		while(armIsReallyBack && (time1[T1] < 300)){//movearm down
			moveArm(true);
			rollerIntake(127);
		}
		startTask(autonConeHold);
		dontMoveArm();

		stopTask(moveLiftDownTask);
		wait1Msec(500);
		moveLiftAuto(-127, 2300);//lift up

		clearTimer(T1);
		armIsReallyBack = false;
		while(!armIsReallyBack && (time1[T1] < 300)){//move arm in
			moveArm(false);
		}
		dontMoveArm();
		startTask(moveLiftDownTask);

		driveAtPosition = false;				//cone 3
		clearTimer(T1);
		clearDriveEnc();
		wait1Msec(150);
		hold = false;								//release cone2
		wait1Msec(100);
		stopTask(moveLiftDownTask); //lift up
		liftUpDistance = 2300;
		startTask(moveLiftUpTask);
		drivePushIn(300, 100);	//push in for other cone

		stopTask(moveLiftUpTask);
		liftDownDistance = 1600;
		startTask(moveLiftDownTask);//move lift down to grab
		armIsReallyBack = true;
		clearTimer(T1);
		hold = true;
		while(armIsReallyBack && (time1[T1] < 300)){//movearm in
			rollerIntake(127);
			moveArm(true);
		}
		startTask(autonConeHold);
		dontMoveArm();

		stopTask(moveLiftDownTask);
		wait1Msec(500);
		moveLiftAuto(-127, 2400);

		clearTimer(T1);
		armIsReallyBack = false;
		while(!armIsReallyBack && (time1[T1] < 300)){
			moveArm(false);
		}
		dontMoveArm();

		liftDownDistance = 2200;//start driving back
		startTask(moveLiftDownTask);
		driveAtPosition = false;
		clearTimer(T1);
		clearDriveEnc();

		while(!driveAtPosition){
			autoDrivePIDControl(-58, true);
			if (time1[T1] > 350)
				hold = false;
		}

		clearTimer(T1);
		turnAtPosition = false;
		while(!turnAtPosition){
			autoGyroPIDControl(200, true);
		}

		clearTimer(T1);
		clearDriveEnc();
		driveAtPosition = false;
		drivePushIn(450, 60);

		hold = false;
		startTask(autonConeHold);
		clearTimer(T1);
		while(time1[T1] < 700)
			moveLiftUp(-127, 2200);

		startTask(holdArmIn);
		moveMobileGoalOutAuto();

		clearTimer(T1);
		clearDriveEnc();
		driveAtPosition = false;
		while(!driveAtPosition && time1[T1] < 600){
			if (time1[T1] > 500)
				moveMobileGoalIn();
			if (time1[T1] > 300)
				drivePushIn(-127);
		}
		drivePushIn(0);
		break;
		/////////////////////////////////////////////////////////////////////////////
		case Interference:
			clearDriveEnc();

			hold = true;
			startTask(autonConeHold);

			clearTimer(T1);
			while(time1[T1] < 4000){
				drivePushIn(-127, 4000);
				wait1Msec(20);
			}
			drivePushIn(0);
			wait1Msec(200);
		break;
		/////////////////////////////////////////////////////////////////////////////
		case Stationary:
			clearDriveEnc();

			hold = true;
			startTask(autonConeHold);

			driveAtPosition = false;
			clearTimer(T1);
			while (!driveAtPosition || time1[T1] < 700) {//drive forward
				if(time1[T1] > 50 && time1[T1] < 400)
					moveLiftUp(-127, 2800);
				if(time1[T1] > 200 && time1[T1] < 500){
					moveArm(true);
				}
				autoDrivePIDControl(24, true);
			}
			dontMoveArm();

			wait1Msec(200);
			hold = false;

			clearDriveEnc();
			driveAtPosition = false;
			clearTimer(T1);
			while (!driveAtPosition) {//drive forward
				autoDrivePIDControl(-20, true);
			}
		break;
		/////////////////////////////////////////////////////////////////////////////
		case Default:

		break;
		}
}

task autonomous()
{
	robotMode = AUTONOMOUS;

	autonomousStartTime = nSysTime;
	writeDebugStreamLine("Starting Autonomous...");

	initialize();

	if (false) AutonomousCodePlaceholderForTesting();  // complains if I remove this

	startTask(autonomousRoutines);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////END AUTONOMOUS PROGRAM SECTION////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

task ProcessController() {
	while(true) {

		/*
		Main Controller:
		joysticks = drive
		Partner Contorller:
		right joystick = catapult
		*/

		// --- Joysticks to control robot driving (main controller only)

		static byte rightJoystickX, leftJoystickY;

		rightJoystickX = readRightJoystickXAxis();
		leftJoystickY = readLeftJoystickYAxis();

		if(isButtonPressed(Btn8D)){
			motor[driveFR] = -20;
			motor[driveFL] = -20;
			motor[driveBR] = 20;
			motor[driveBL] = 20;
			} else {
			motor[driveFR] = motor[driveBR] = (((abs(leftJoystickY) > MIN_JOYSTICK_THRESHOLD) ? leftJoystickY : 0)  - ((abs(rightJoystickX) > MIN_JOYSTICK_THRESHOLD ? rightJoystickX : 0)));
			motor[driveFL] = motor[driveBL] = (((abs(leftJoystickY) > MIN_JOYSTICK_THRESHOLD) ? leftJoystickY : 0)  + ((abs(rightJoystickX) > MIN_JOYSTICK_THRESHOLD ? rightJoystickX : 0)));
		}

		//Mobile Goal control on joystick
		if (isButtonPressed(Btn6U) && (SensorValue[mobilePot] < 3525)) {
			motor[mobileGoal] = -127;
			} else if (isButtonPressed(Btn6D) && (SensorValue[mobilePot] > 395)) {
			motor[mobileGoal] = 127;
			}	else {
			motor[mobileGoal] = 0;
		}

		stacking = false;

		//Roller control
		if (!stacking) {
			if (isButtonPressed(Btn8DXmtr2)) {
				motor[roller] = 127;
				} else if (isButtonPressed(Btn7DXmtr2)) {
				motor[roller] = -127;
				} else {
				//motor[roller] = 25;
				motor[roller] = ROLLER_DEFAULT_RATE;
			}
		}

		//Move lift
		if (!stacking) {
			if (isButtonPressed(Btn6UXmtr2) && ((SensorValue[liftLeftPot] + SensorValue[liftRightPot]) / 2) < 4085) {
				motor[liftL] = motor[liftR] = -127;
				//liftPIDControl(1000);
				} else if (isButtonPressed(Btn6DXmtr2) && ((SensorValue[liftLeftPot] + SensorValue[liftRightPot]) / 2) > 1800) {
				motor[liftL] = motor[liftR] = 127; //liftPIDControl(500);

			}
			else {
				motor[liftL] = motor[liftR] = 0;
			}
		}

		//Move Arm

		if (!stacking) {
			if (isButtonPressed(Btn5UXmtr2) && (SensorValue[armPot] > 30)) {
				motor[intBarL] = motor[intBarR] = 127;
				} else if (isButtonPressed(Btn5DXmtr2) && (SensorValue[armPot] < 1830)) {
				motor[intBarL] = motor[intBarR] = -127;
				} else {
				motor[intBarL] = motor[intBarR] = 0;
			}
		}

		datalogAddValueWithTimeStamp(6, vexRT[Ch3]);
		datalogAddValueWithTimeStamp(5, vexRT[Ch1]);

		// --- Choose alliance if both Left & Right LCD Buttons are pressed

		if ((nLCDButtons & (kButtonLeft | kButtonRight)) == (kButtonLeft | kButtonRight)) {
			selectTeamAlliance();
		}

		wait1Msec(15);
	}
}

task usercontrol()
{
	robotMode = USER_CONTROL;


	writeDebugStreamLine("Starting User Control...");
	writeDebugStreamLine("Main battery level: %3.2f", nAvgBatteryLevel * 0.001);
	writeDebugStreamLine("Backup battery level: %3.2f", BackupBatteryLevel * 0.001);

	initialize();

	startTask(ProcessController);
}

void initialize()
{
	// Library routines thread
	startTask(activateLib);


	//Clear Sensors

	SensorValue[DriveEnc] = 0;


	stacking = false;
	stackPrev = false;
	liftLeftAtPosition = false;
	liftRightAtPosition = false;
	armIsReallyBack = true;
	increaseStackLvl = false;
	justStacked = false;
	outakeFinished = false;

	datalogClear();
	writeDebugStreamLine("Main battery level: %3.2f", nAvgBatteryLevel * 0.001);
	writeDebugStreamLine("Backup battery level: %3.2f", BackupBatteryLevel * 0.001);
}

void timerCallback(unsigned int timerId)
{

}

void selectTeamAlliance()
{

	// Clear LCD and turn on backlight
	clearLCDLine(0);
	clearLCDLine(1);
	bLCDBacklight = true;

	byte scrolledAuto = Default;

	bool autonomousSelected = false;
	int scrollCount = 1;

	if (bIfiRobotDisabled){
		while (!autonomousSelected && bIfiRobotDisabled) {
			// Wait for button press
			if(nLCDButtons == 1) {
				scrollCount -= 1;
			}
			if(nLCDButtons == 4) {
				scrollCount += 1;
			}
			if(nLCDButtons == 2) {
				autonomousMode = scrolledAuto;
				autonomousSelected = true;
			}

			switch (scrollCount) {
			case 1:
				scrolledAuto = AUTONOMOUS_MODE_LEFT_2MOBILE_GOAL_20;
				displayLCDString(1, 0, "1-left2mogo20");
				wait1Msec(200);
				break;

			case 2:
				scrolledAuto = AUTONOMOUS_MODE_RIGHT_2MOBILE_GOAL_20;
				displayLCDString(1, 0, "2-right2mogo20");
				wait1Msec(200);
				break;

			case 3:
				scrolledAuto = AUTONOMOUS_MODE_RIGHT_3MOBILE_GOAL_10;
				displayLCDString(1, 0, "3-right3mogo10");
				wait1Msec(200);
				break;

			case 4:
				scrolledAuto = AUTONOMOUS_MODE_LEFT_3MOBILE_GOAL_10;
				displayLCDString(1, 0, "4-left3mogo10");
				wait1Msec(200);
				break;

			case 5:
				scrolledAuto = AUTONOMOUS_MODE_RIGHT_3MOBILE_GOAL_5;
				displayLCDString(1, 0, "5-right3mogo5   ");
				wait1Msec(200);
				break;

			case 6:
				scrolledAuto = AUTONOMOUS_MODE_LEFT_3MOBILE_GOAL_5;
				displayLCDString(1, 0, "6-left3mogo5   ");
				wait1Msec(200);
				break;

			case 7:
				scrolledAuto = AUTONOMOUS_MODE_RIGHT_MOBILE_GOAL_20;
				displayLCDString(1, 0, "7-right1mogo20   ");
				wait1Msec(200);
				break;

			case 8:
				scrolledAuto = AUTONOMOUS_MODE_LEFT_MOBILE_GOAL_20;
				displayLCDString(1, 0, "8-left1mogo20  ");
				wait1Msec(200);
				break;

			case 9:
				scrolledAuto = Interference;
				displayLCDString(1, 0, "9-Interference");
				wait1Msec(200);
				break;
			case 10:
				scrolledAuto = Stationary;
				displayLCDString(1, 0, "10-Stationary");
				wait1Msec(200);
				break;
			case 11:
				scrolledAuto = Default;
				displayLCDString(1, 0, "11-Default");
				wait1Msec(200);
				break;
			}
			wait1Msec(10);
		}
	}
	else{
		byte scrolledAuto = Default;
		autonomousMode = scrolledAuto;
	}

	wait1Msec(500);

	// Clear LCD
	clearLCDLine(0);
	clearLCDLine(1);
}

void initializeGyro() {
	writeDebugStreamLine("Gyro before initialize %d", SensorValue[in8]);

	SensorFullCount[driveGyro] = 7200;

	SensorType(driveGyro) = sensorNone;
	wait1Msec(1000);
	SensorType(driveGyro) = sensorGyro;
	wait1Msec(2000);

	writeDebugStreamLine("Gyro after initialize %d", SensorValue[in8]);
}

//////////////////////////////////////////////////////Auton Functions/////////////////////////////////////////////
task holdArmIn(){
	clearTimer(T3);
	while(time1[T3] < 700){
		motor[intBarL] = motor[intBarR] = 127;
		wait1Msec(20);
	}
	motor[intBarL] = motor[intBarR] = 0;
	stopTask(holdArmIn);

}

void moveArmOut () {
	if (SensorValue[armPot] > 30) {
		motor[intBarL] = motor[intBarR] = -120;
		armPower = -120;
		armIsReallyBack = true;
	} else {
		motor[intBarL] = motor[intBarR] = 0;
		armPower = 0;
		armIsReallyBack = false;
	}

}

void moveArmIn() {
	if (SensorValue[armPot] < 1830) {
		motor[intBarL] = motor[intBarR] = 120;
		armPower = 120;
		writeDebugStreamLine("swinging arm pot %d", SensorValue[armPot]);
		armIsReallyBack = false;
		} else {
		motor[intBarL] = motor[intBarR] = 0;
		armPower = 0;
		armIsReallyBack = true;
	}

}

void moveArm (bool forward) {
	if (forward) {
		moveArmOut();
		} else {
		moveArmIn();
	}
}

void dontMoveArm (){
	motor[intBarL] = motor[intBarR] = 0;
	armPower = 0;
}

void rollerIntake(int speed) {
	motor[roller] = speed;
	rollerSpeed = speed;
	writeDebugStreamLine("Set speed %d", rollerSpeed);
}

void rollerOutake(int speed, int time) {
	if (time1[T3] < time) {
		motor[roller] = speed;
		} else {
		motor [roller] = 0;
		outakeFinished = true;
	}
}

//Drive function for auto
void drive(int left, int right) {
	turnMotor(driveFL, left);
	turnMotor(driveFR, right);
	turnMotor(driveBL, left);
	turnMotor(driveBR, right);
}

//Drive function with encoders for auto

void clearDriveEnc() {
	SensorValue[DriveEnc] = 0;
}

///////////////////////////////////////////MOBILE GOAL//////////////////////////////////////////////////////
void  moveMobileGoalIn() {
	if (SensorValue[mobilePot] < 3525) {
		motor[mobileGoal] = -127;
		mobileGoalIsOut = true;
		} else {
		motor[mobileGoal] = 0;
		mobileGoalIsOut = false;
	}
}

void moveMobileGoalInAuto() {
	while (SensorValue[mobilePot] < 3525) {
		motor[mobileGoal] = -127;
	}
	motor[mobileGoal] = 0;
}

void moveMobileGoalOut() {
	if (SensorValue[mobilePot] > 395) {
		motor[mobileGoal] = 127;
		mobileGoalIsOut = false;
		} else {
		motor[mobileGoal] = 0;
		mobileGoalIsOut = true;
	}
}

void moveMobileGoalOutAuto() {
	while (SensorValue[mobilePot] > 395) {
		motor[mobileGoal] = 127;
	}
	motor[mobileGoal] = 0;
}


////////////////////////////////////////////////////////////LIFT FUNCTIONS/////////////////////////////////////////////////////////

void moveLiftUp(int speed, int distance) {
	if (((SensorValue[liftLeftPot] + SensorValue[liftRightPot])/2) < distance) {
		motor [liftL] = speed;
		motor [liftR] = speed;
		} else {
		motor [liftL] = 0;
		motor [liftR] = 0;
	}
}

void moveLiftDown(int speed, int distance){
	if (((SensorValue[liftLeftPot] + SensorValue[liftRightPot])/2) > distance){
		motor [liftL] = 127;
		motor [liftR] = 127;
		} else {
		motor [liftL] = 0;
		motor [liftR] = 0;
	}
}

void moveLiftAuto(int speed, int distance) {
	while (((SensorValue[liftLeftPot] + SensorValue[liftRightPot])/2) < distance) {
		motor [liftL] = speed;
		motor [liftR] = speed;
	}
	motor [liftL] = 0;
	motor [liftR] = 0;
}

task moveLiftDownTask() {
	while (((SensorValue[liftLeftPot] + SensorValue[liftRightPot])/2) > liftDownDistance){
		motor [liftL] = motor [liftR] = 127;
	}
	motor [liftL] = motor [liftR] = 0;
	stopTask(moveLiftDownTask);
}

task moveLiftUpTask() {
	while (((SensorValue[liftLeftPot] + SensorValue[liftRightPot])/2) < liftUpDistance){
		motor [liftL] = motor [liftR] = -127;
	}
	motor [liftL] = motor [liftR] = 0;
	stopTask(moveLiftUpTask);
}
////////////////////////////////////////////////////Drive Functions//////////////////////////////////////////////////////

void drivePushIn(){
	motor[driveFR] = 70;
	motor[driveFL] = 70;
	motor[driveBR] = 70;
	motor[driveBL] = 70;
	wait1Msec(300);
	motor[driveFR] = 0;
	motor[driveFL] = 0;
	motor[driveBR] = 0;
	motor[driveBL] = 0;
}

void drivePushIn(int speed){
	motor[driveFR] = speed;
	motor[driveFL] = speed;
	motor[driveBR] = speed;
	motor[driveBL] = speed;
}

void drivePushIn(int timeToMove, int speed){
	motor[driveFR] = speed;
	motor[driveFL] = speed;
	motor[driveBR] = speed;
	motor[driveBL] = speed;
	wait1Msec(timeToMove);
	motor[driveFR] = 0;
	motor[driveFL] = 0;
	motor[driveBR] = 0;
	motor[driveBL] = 0;
}

task autonConeHold(){
	bool looping = true;

	if (hold){
		motor[roller] = 80;
		writeDebugStream("holding cone");
		wait1Msec(400);
	}
	while (looping){
		if (hold)
			motor[roller] = 15;
		else{
			motor[roller] = -127;
			wait1Msec(300);
			looping = false;
			motor[roller] = 0;
		}
	}
	stopTask(autonConeHold);
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////PID VALUE CALCULATION AND FUNCTIONS//////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void autoDrivePIDControl (int distance, bool drive) {
	float encAverage = SensorValue[DriveEnc];//add second encoder if you want on both sides

	float integralAcitveZone = 100;

	float valueDistance;
	float error;
	float proportion;
	float integral;
	float derivative;

	float errorT;
	float lastError;

	float current;

	valueDistance = (float)distance * PID_ENCODER_SCALE;
	//Find Distance error
	error = valueDistance - encAverage;

	if (drive) {
		//Set proportion
		proportion = error * drivekp;
		integral = errorT * driveki;
		derivative = (error - lastError) * drivekd;
		} else if (!drive) {
		//Set proportion for turn drive
		proportion = error * driveTurnkp;
		integral = errorT * driveTurnki;
		derivative = (error - lastError) * driveTurnkd;
	}

	//Calculate integral
	//left
	if (errorT < integralAcitveZone) {
		errorT += error;
		} else {
		errorT = 0;
	}

	lastError = error;

	//Set current
	current = proportion + integral + derivative;
	driveCurrent = proportion + integral + derivative;

	if (abs(error) <= drivePositionError) {
		current = 0;
		clearTimer(T1);
	}

	if (abs(error) <= driveTurnPositionError) {
		gyroCurrent = 0;
	}

	//Check that drive has stopped
	if ((abs(error) <= drivePositionError && time1[T1] < 1000) || time1[T1] > 2000) {
		driveAtPosition = true;
		} else {
		driveAtPosition = false;
	}

	if (current > 127) {
		current = 127;
	}
	if (current < -127) {
		current = -127;
	}

	if (drive && abs(error) > 80) {
		motor[driveBL] = (int)current + bias;
		motor[driveFL] = (int)current + bias;
		motor[driveBR] = (int)current - bias;
		motor[driveFR] = (int)current - bias;
	}
	else if(drive && abs(error) <= 80 ){
		motor[driveBL] = (int)current;
		motor[driveFL] = (int)current;
		motor[driveBR] = (int)current;
		motor[driveFR] = (int)current;
	}


	writeDebugStreamLine("             drive current %d", current);
	writeDebugStreamLine("             proportion %d", proportion);
	writeDebugStreamLine("             error %d", error);
	writeDebugStreamLine("encoder %d", encAverage);
}

void autoGyroPIDControl (int setAngle, bool turn) {
	float currentAngle = SensorValue(driveGyro);

	float integralAcitveZone = 1000;

	float proportion;
	float integral;
	float derivative;

	float errorT;
	float lastError;

	float current;

	//Find Angle error
	turnError = (setAngle * PID_GYRO_SCALE) - currentAngle;

	if (turn) {
		//Set proportion
		proportion = turnError * turnkp;
		integral = errorT * turnki;
		derivative = (turnError - lastError) * turnkd;
		} else if (!turn) {
		//Set proportion for turn drive
		proportion = turnError * (turnDrivekp + (setAngle<180 ? 0.3 : 0));
		integral = errorT * turnDriveki;
		derivative = (turnError - lastError) * turnDrivekd;
	}

	//Calculate integral
	if (turnError < integralAcitveZone) {
		errorT += turnError;
		} else {
		errorT = 0;
	}

	//Calculate derivative
	lastError = turnError;

	//Set current
	current = proportion + integral + derivative;
	gyroCurrent = proportion + integral + derivative;

	if (abs(turnError) <= turnPositionError) {
		current = 0;
	}


	if (abs(turnError) <= turnPositionError || time1[T1] > 1000) {
		turnAtPosition = true;
		} else {
		turnAtPosition = false;
	}

	if (current > 127) {
		current = 127;
	}
	if (current < -127) {
		current = -127;
	}
	if (turn) {
		motor[driveBL] = current + bias;
		motor[driveFL] = current + bias;
		motor[driveBR] = -current - .5*bias;
		motor[driveFR] = -current - .5*bias;
	}

	writeDebugStreamLine("Current Angle %d", currentAngle);
	writeDebugStreamLine("            turn error %d", turnError);
	writeDebugStreamLine("            angle current 2/ %d", current);

	datalogAddValueWithTimeStamp(4, turnError);
}
